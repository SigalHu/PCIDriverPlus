#ifndef _PCI_DRIVER_LIB_H_
#define _PCI_DRIVER_LIB_H_

/************************************************************************
*  File: pci_driver_lib.h
*
*  Library for accessing PCI_DRIVER devices.
*  The code accesses hardware using WinDriver's WDC library.
*  Code was generated by DriverWizard v10.00.
*
*  Jungo Confidential. Copyright (c) 2014 Jungo Ltd.  http://www.jungo.com
*************************************************************************/

#include "wdc_lib.h"
#include "samples/shared/pci_regs.h"
#include "samples/shared/bits.h"

#ifdef __cplusplus
extern "C" {
#endif

/*************************************************************
  General definitions
 *************************************************************/
/* Default vendor and device IDs */
#define PCI_DRIVER_DEFAULT_VENDOR_ID 0x104C /* Vendor ID */
#define PCI_DRIVER_DEFAULT_DEVICE_ID 0xB000 /* Device ID */


/* Address space information struct */
#define MAX_TYPE 8
typedef struct {
    DWORD dwAddrSpace;
    CHAR sType[MAX_TYPE];
    CHAR sName[MAX_NAME];
    CHAR sDesc[MAX_DESC];
} PCI_DRIVER_ADDR_SPACE_INFO;

// hu ///////////////////////////////////////////////////
#define BAR0 0
#define BAR1 1
#define BAR2 2
#define BAR3 3
#define BAR4 4
#define BAR5 5


//void * EDMA_Receive;
/////////////////////////////////////////////////////////

/* Interrupt result information struct */
typedef struct
{
    DWORD dwCounter; /* Number of interrupts received */
    DWORD dwLost;    /* Number of interrupts not yet handled */
    WD_INTERRUPT_WAIT_RESULT waitResult; /* See WD_INTERRUPT_WAIT_RESULT values in windrvr.h */
    DWORD dwEnabledIntType; /* Interrupt type that was actually enabled
                               (MSI/MSI-X/Level Sensitive/Edge-Triggered) */
    DWORD dwLastMessage; /* Message data of the last received MSI/MSI-X
                        (Windows Vista); N/A to line-based interrupts) */
} PCI_DRIVER_INT_RESULT;
/* TODO: You can add fields to PCI_DRIVER_INT_RESULT to store any additional
         information that you wish to pass to your diagnostics interrupt
         handler routine (DiagIntHandler() in pci_driver_diag.c) */

/* PCI_DRIVER diagnostics interrupt handler function type */
typedef void (*PCI_DRIVER_INT_HANDLER)(WDC_DEVICE_HANDLE hDev,
    PCI_DRIVER_INT_RESULT *pIntResult);

/* PCI_DRIVER diagnostics plug-and-play and power management events handler function type */
typedef void (*PCI_DRIVER_EVENT_HANDLER)(WDC_DEVICE_HANDLE hDev,
    DWORD dwAction);

// hu ///////////////////////////////////////////////////////////////
DWORD initialize_PCI(int deviceX);
DWORD Write(int deviceX,int barX, DWORD dwoffset, UINT32 write32,unsigned int repeatTimes);
DWORD Write_256Words(int deviceX,int barX, DWORD dwoffset, UINT32 *write1M);
DWORD Read(int deviceX,int barX, DWORD dwoffset, UINT32 *read32);
DWORD Read_256Words(int deviceX,int barX, DWORD dwoffset, UINT32 *read1M);
DWORD Interrupt_1(int deviceX);
void  DiagIntHandler_0(WDC_DEVICE_HANDLE hDev, PCI_DRIVER_INT_RESULT *pIntResult);
void  DiagIntHandler_1(WDC_DEVICE_HANDLE hDev, PCI_DRIVER_INT_RESULT *pIntResult);
void  DiagIntHandler_2(WDC_DEVICE_HANDLE hDev, PCI_DRIVER_INT_RESULT *pIntResult);
void  DiagIntHandler_3(WDC_DEVICE_HANDLE hDev, PCI_DRIVER_INT_RESULT *pIntResult);
void  DiagIntHandler_4(WDC_DEVICE_HANDLE hDev, PCI_DRIVER_INT_RESULT *pIntResult);
DWORD DisInterrupt_1(int deviceX);
DWORD SendInterrupt(int deviceX);
DWORD ApplyForPhysicalAddress(int deviceX, DWORD dwDMABufSize, PVOID * pBufAddress, DWORD * pBufPhysicalAddress, DWORD * DMAHandle);
DWORD FreePhysicalAddress(int deviceX, DWORD DMAHandle);
DWORD Close_PCI(int deviceX);
//void memcpy_to_pBuffSend(void * RandGroupToDSP);
//void memcpy_to_EDMA_Receive(void * EDMA_Receive);
/////////////////////////////////////////////////////////////////////

/*************************************************************
  Function prototypes
 *************************************************************/
DWORD PCI_DRIVER_LibInit(void);
DWORD PCI_DRIVER_LibUninit(void);

WDC_DEVICE_HANDLE PCI_DRIVER_DeviceOpen(const WD_PCI_CARD_INFO *pDeviceInfo);
BOOL PCI_DRIVER_DeviceClose(WDC_DEVICE_HANDLE hDev);

// hu //static BOOL IsItemExists(PWDC_DEVICE pDev, ITEM_TYPE item);
DWORD PCI_DRIVER_IntEnable(WDC_DEVICE_HANDLE hDev, PCI_DRIVER_INT_HANDLER funcIntHandler);
DWORD PCI_DRIVER_IntDisable(WDC_DEVICE_HANDLE hDev);
BOOL PCI_DRIVER_IntIsEnabled(WDC_DEVICE_HANDLE hDev);

DWORD PCI_DRIVER_EventRegister(WDC_DEVICE_HANDLE hDev, PCI_DRIVER_EVENT_HANDLER funcEventHandler);
DWORD PCI_DRIVER_EventUnregister(WDC_DEVICE_HANDLE hDev);
BOOL PCI_DRIVER_EventIsRegistered(WDC_DEVICE_HANDLE hDev);

DWORD PCI_DRIVER_GetNumAddrSpaces(WDC_DEVICE_HANDLE hDev);
BOOL PCI_DRIVER_GetAddrSpaceInfo(WDC_DEVICE_HANDLE hDev, PCI_DRIVER_ADDR_SPACE_INFO *pAddrSpaceInfo);


const char *PCI_DRIVER_GetLastErr(void);

#ifdef __cplusplus
}
#endif

#endif
