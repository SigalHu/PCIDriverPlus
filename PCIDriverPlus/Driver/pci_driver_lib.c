/************************************************************************
*  File: pci_driver_lib.c
*
*  Library for accessing PCI_DRIVER devices.
*  The code accesses hardware using WinDriver's WDC library.
*  Code was generated by DriverWizard v10.00.
*
*  Jungo Confidential. Copyright (c) 2014 Jungo Ltd.  http://www.jungo.com
*************************************************************************/

#include <stdio.h>
#include <stdarg.h>
#include "wdc_defs.h"
#include "utils.h"
#include "status_strings.h"
#include "pci_driver_lib.h"
// hu ///////////////////////////////////////////////////////////
#include "pci_driver_lib_head.h"
/////////////////////////////////////////////////////////////////

/*************************************************************
  Internal definitions
 *************************************************************/
/* WinDriver license registration string */
/* TODO: When using a registered WinDriver version, make sure the license string
         below is your specific WinDriver license registration string and set 
 * the driver name to your driver's name */
#define PCI_DRIVER_DEFAULT_LICENSE_STRING "6C3CC2CFE89E7AD0425ECCB375D728D6B53BF05F.EMBRACE"
#define PCI_DRIVER_DEFAULT_DRIVER_NAME "windrvr6"
// hu /////////////////////////////////////////
//#define DEBUG 1
///////////////////////////////////////////////
/* PCI_DRIVER device information struct */
typedef struct {
    PCI_DRIVER_INT_HANDLER   funcDiagIntHandler;
    PCI_DRIVER_EVENT_HANDLER funcDiagEventHandler;
} PCI_DRIVER_DEV_CTX, *PPCI_DRIVER_DEV_CTX;
/* TODO: You can add fields to store additional device-specific information */
// hu //////////////////////////////////////////////////////////
WDC_DEVICE_HANDLE         hDevNow= NULL;
WDC_DEVICE_HANDLE         hDev[DEVNUM_MAX]= {NULL};

unsigned int Int_Flag = 99 ;

//PVOID pBufSend = NULL; //## 申请物理地址的映射地址
//PVOID pBufReceive = NULL; //## 申请物理地址的映射地址
//huWD_DMA *pDmaSend = NULL;
//huWD_DMA *pDmaReceive = NULL;
WD_DMA * pDmaGroup[DEVNUM_MAX][10];
//hu//int pDmaGroup_0_flag;
// hu WD_DMA * pDmaGroup_1 [10];
//hu//int pDmaGroup_1_flag;

/////////////////////////////////////////////////////////////////

static CHAR gsPCI_DRIVER_LastErr[256];

static DWORD LibInit_count = 0;
/*************************************************************
  Static functions prototypes and inline implementation
 *************************************************************/
static BOOL DeviceValidate(const PWDC_DEVICE pDev);
static void DLLCALLCONV PCI_DRIVER_IntHandler(PVOID pData);
static void PCI_DRIVER_EventHandler(WD_EVENT *pEvent, PVOID pData);
static void ErrLog(const CHAR *sFormat, ...);
static void TraceLog(const CHAR *sFormat, ...);
// hu //////////////////////////////////////////////////////////
static BOOL IsItemExists(PWDC_DEVICE pDev, ITEM_TYPE item);
////////////////////////////////////////////////////////////////

static inline BOOL IsValidDevice(PWDC_DEVICE pDev, const CHAR *sFunc)
{
    if (!pDev || !WDC_GetDevContext(pDev))
    {
        snprintf(gsPCI_DRIVER_LastErr, sizeof(gsPCI_DRIVER_LastErr) - 1, "%s: NULL device %s\n",
            sFunc, !pDev ? "handle" : "context");
        ErrLog(gsPCI_DRIVER_LastErr);
        return FALSE;
    }

    return TRUE;
}

/*************************************************************
  Functions implementation
 *************************************************************/

// hu 注册Windriver，扫描pci器件，获得操作句柄
// 返回值：0 -- 成功 
//         1 -- 未扫描到PCI设备
//         2 -- 获取设备驱动操作句柄失败
//         3 -- 初始化设备驱动库失败
DWORD initialize_PCI(int deviceX)
{
	int ii,jj;
	PPCI_DRIVER_DEV_CTX          pDevCtx = NULL;
    DWORD dwStatus;
	
	WDC_PCI_SCAN_RESULT scanResult;
	WD_PCI_CARD_INFO    deviceInfo;

	TraceLog("hu: Start to run the function: initialize_PCI...\n");
		
    /* Initialize the pci driver library */
    dwStatus = PCI_DRIVER_LibInit();   
    if (WD_STATUS_SUCCESS != dwStatus)   
    {
		WDC_Err("hu: Failed to initialize the PCI driver library. Error 0x%lx - %s\n",dwStatus, Stat2Str(dwStatus));
		return 3;
    }
	
    /* Find and open a TEST_1 device (by default ID) */
    //if (TEST_1_DEFAULT_VENDOR_ID)  //## #define TEST_1_DEFAULT_VENDOR_ID 0x104C /* Vendor ID */
		//  hDev = DeviceFindAndOpen(TEST_1_DEFAULT_VENDOR_ID, TEST_1_DEFAULT_DEVICE_ID); 
		//## #define TEST_1_DEFAULT_DEVICE_ID 0xB000 /* Device ID */
		///////////////////////////////////////////////////////////	
	dwStatus = WDC_PciScanDevices(0x104C, 0xB000, &scanResult);
	if (WD_STATUS_SUCCESS != dwStatus)
	{
		WDC_Err("hu: Failed to scan the PCI driver. Error 0x%lx - %s\n",dwStatus, Stat2Str(dwStatus));
		return 1;
	}
	// hu scanResult.dwNumDevices;// hu 搜索到的设备个数
	if (deviceX >= scanResult.dwNumDevices)
	{
		WDC_Err("hu: Failed to scan the PCI driver. Error 0x%lx - %s\n",dwStatus, Stat2Str(dwStatus));
		return 1;
	}

	deviceInfo.pciSlot = scanResult.deviceSlot[deviceX];//scanResult.dwNumDevices  - 1
	WDC_PciGetDeviceInfo(&deviceInfo);
		
	hDevNow = PCI_DRIVER_DeviceOpen(&deviceInfo);
	if (NULL == hDevNow)
    {
		WDC_Err("hu: Failed to find the handle to the PCI driver%d.\n",deviceX);
		return 2;
    }
	hDev[deviceX] = hDevNow;

	//## 初始化申请内存指针和flag
	for (ii=0;ii<DEVNUM_MAX;ii++)
	{
		for (jj=0;jj<10;jj++)
		{
			pDmaGroup[ii][jj] = 0;
		}
	}
	// hu //pDmaGroup_0_flag = 0;
	// hu //pDmaGroup_0_flag = 0;

	TraceLog("hu: Succeed to initialize the PCI driver%d.\n",deviceX);
	return 0;
}

// hu 向PCI设备写入1个字
// 返回值：0 -- 成功 
//         1 -- PCI设备写入失败
DWORD Write(int deviceX,int barX, DWORD dwoffset, UINT32 write32,unsigned int repeatTimes)
{	
	DWORD dwStatus;
	int ii;

	TraceLog("hu: Start to run the function: Write...\n");

	hDevNow = hDev[deviceX];
    
	for (ii=0;ii<repeatTimes;ii++)
	{
		dwStatus = WDC_WriteAddr32(hDevNow, barX, dwoffset, write32);
		if (WD_STATUS_SUCCESS != dwStatus)
		{
			WDC_Err("hu: Failed to write a word to the PCI driver%d. Error 0x%lx - %s\n",deviceX,dwStatus, Stat2Str(dwStatus));
			return 1;
		}
	}

	TraceLog("hu: Succeed to write a word to the PCI driver%d.\n",deviceX);
	return 0;
}

// hu 向PCI设备写入256个字
// 返回值：0 -- 成功 
//         1 -- PCI设备写入失败
DWORD Write_256Words(int deviceX,int barX, DWORD dwoffset, UINT32 *write256Words)
{	
	int i=0;
	DWORD dwStatus;

	TraceLog("hu: Start to run the function: Write_256Words...\n");

	hDevNow = hDev[deviceX];

	for(i=0; i<256; i++)
	{
		dwStatus = WDC_WriteAddr32(hDevNow, barX, dwoffset+i*4, *(write256Words+i));
		if (WD_STATUS_SUCCESS != dwStatus)
		{
			WDC_Err("hu: Failed to write %d/256 words to the PCI driver%d. Error 0x%lx - %s\n",i+1,deviceX,dwStatus, Stat2Str(dwStatus));
			return 1;
		}
	}

	TraceLog("hu: Succeed to write %d/256 words to the PCI driver%d.\n",i+1,deviceX);
	return 0;
}

// hu 向PCI设备读取1个字
// 返回值：0 -- 成功 
//         1 -- PCI设备读取失败
DWORD Read(int deviceX,int barX, DWORD dwoffset, UINT32 *read32)
{
	DWORD dwStatus;

	TraceLog("hu: Start to run the function: Read...\n");

	hDevNow = hDev[deviceX];

	dwStatus = WDC_ReadAddr32(hDevNow, barX, dwoffset, read32);
	if (WD_STATUS_SUCCESS != dwStatus)
	{
		WDC_Err("hu: Failed to read a word from the PCI driver%d. Error 0x%lx - %s\n",deviceX,dwStatus, Stat2Str(dwStatus));
		return 1;
	}
	
	TraceLog("hu: Succeed to read a word from the PCI driver%d.\n",deviceX);
	return 0;
}

// hu 向PCI设备读取256个字
// 返回值：0 -- 成功 
//         1 -- PCI设备读取失败
DWORD Read_256Words(int deviceX,int barX, DWORD dwoffset, UINT32 *read256Words)//hu读1M数据
{	
	int i = 0;
	DWORD dwStatus;
	
	TraceLog("hu: Start to run the function: Read_256Words...\n");

	hDevNow = hDev[deviceX];

	for(i=0; i<256; i++)
	{
		dwStatus = WDC_ReadAddr32(hDevNow, barX, dwoffset+i*4, read256Words+i);
		if (WD_STATUS_SUCCESS != dwStatus)
		{
			WDC_Err("hu: Failed to read %d/256 words from the PCI driver%d. Error 0x%lx - %s\n",i+1,deviceX,dwStatus, Stat2Str(dwStatus));
			return 1;
		}
	}

	TraceLog("hu: Succeed to read %d/256 words from the PCI driver%d.\n",i+1,deviceX);
	return 0;
}

// hu 使能PCI中断
// 返回值：0 -- 成功 
//         1 -- 使能PCI中断失败
DWORD Interrupt_1(int deviceX)
{
	DWORD dwStatus;
	
	TraceLog("hu: Start to run the function: Interrupt_1...\n");

	hDevNow = hDev[deviceX];
	switch(deviceX)
	{
	case 0:
		dwStatus = PCI_DRIVER_IntEnable(hDevNow, DiagIntHandler_0);// hu 不停调用DiagIntHandler_0()来诊断中断
		break;
	case 1:
		dwStatus = PCI_DRIVER_IntEnable(hDevNow, DiagIntHandler_1);
		break;
	case 2:
		dwStatus = PCI_DRIVER_IntEnable(hDevNow, DiagIntHandler_2);
		break;
	case 3:
		dwStatus = PCI_DRIVER_IntEnable(hDevNow, DiagIntHandler_3);
		break;
	case 4:
		dwStatus = PCI_DRIVER_IntEnable(hDevNow, DiagIntHandler_4);
		break;
	}
	if (WD_STATUS_SUCCESS != dwStatus)
	{
		WDC_Err("hu: Failed to enable the interrupts of the PCI driver%d. Error 0x%lx - %s\n",deviceX,dwStatus, Stat2Str(dwStatus));
		return 1;
	}

	TraceLog("hu: Succeed to enable the interrupts of the PCI driver%d.\n",deviceX);
    return 0;
}

// hu 用户模式下的中断句柄回调函数
// 作用：该函数在收到中断后将被执行
void DiagIntHandler_0(WDC_DEVICE_HANDLE hDev_0, PCI_DRIVER_INT_RESULT *pIntResult) //## 此中断函数会被PC机不停调用，
{																		//##必须把需要的处理程序写在“添加中断处理程序处”
/* TODO: You can modify this function in order to implement your own
	diagnostics interrupt handler routine */
	// PWDC_DEVICE pDev = (PWDC_DEVICE)hDev;
	UINT32 RdReg;
//	Int_Flag = 0;

	WDC_ReadAddr32(hDev_0, BAR2, 0x02C00010-0x02800000, &RdReg);//判断是否为DSP发起的中断
	if ((RdReg & 0x08000000) == 0x08000000)
	{
		WDC_ReadAddr32(hDev_0, BAR2, 0x02C00014-0x02800000, &RdReg);//获取PCISTATCLR
		RdReg = RdReg | 0x08000000;
		WDC_WriteAddr32(hDev_0, BAR2, 0x02C00014-0x02800000, RdReg);  //清中断

		WDC_ReadAddr32(hDev_0, BAR2, 0x02C00024-0x02800000, &RdReg);//获取PCIHINTCLR
		RdReg = RdReg | 0x08000000;
		WDC_WriteAddr32(hDev_0, BAR2, 0x02C00024-0x02800000, RdReg);  //关中断
		Int_Flag=3;
		//----------------------------------------------
		//-----------添加中断处理程序------------------
	//	WDC_DMASyncIo(pDmaReceive);
	//	memcpy(EDMA_Receive,pBufReceive,4*1024);
	//	WDC_DMABufUnlock(pDmaReceive);
		TraceLog("hu: Succeed to receive the interrupt%d of the PCI driver0.\n",Int_Flag);
		PostMessage(ghWnd[0],WM_CALLBACKMESSAGE_0,Int_Flag,0);
		
		
		//----------------------------------------------
		WDC_ReadAddr32(hDev_0, BAR2, 0x02C00020-0x02800000, &RdReg);//获取PCIHINTSET
		RdReg = RdReg | 0x08000000;
		WDC_WriteAddr32(hDev_0, BAR2, 0x02C00020-0x02800000, RdReg);  //开中断
	}
	else if ((RdReg & 0x04000000) == 0x04000000)
	{
		WDC_ReadAddr32(hDev_0, BAR2, 0x02C00014-0x02800000, &RdReg);//获取PCISTATCLR
		RdReg = RdReg | 0x04000000;
		WDC_WriteAddr32(hDev_0, BAR2, 0x02C00014-0x02800000, RdReg);  //清中断
		
		WDC_ReadAddr32(hDev_0, BAR2, 0x02C00024-0x02800000, &RdReg);//获取PCIHINTCLR
		RdReg = RdReg | 0x04000000;
		WDC_WriteAddr32(hDev_0, BAR2, 0x02C00024-0x02800000, RdReg);  //关中断
		Int_Flag=2;
		//----------------------------------------------
		//-----------添加中断处理程序------------------
		TraceLog("hu: Succeed to receive the interrupt%d of the PCI driver0.\n",Int_Flag);
		PostMessage(ghWnd[0],WM_CALLBACKMESSAGE_0,Int_Flag,0);
		
		
		//----------------------------------------------
		WDC_ReadAddr32(hDev_0, BAR2, 0x02C00020-0x02800000, &RdReg);//获取PCIHINTSET
		RdReg = RdReg | 0x04000000;
		WDC_WriteAddr32(hDev_0, BAR2, 0x02C00020-0x02800000, RdReg);  //开中断
	}
	else if ((RdReg & 0x02000000) == 0x02000000)
	{
		WDC_ReadAddr32(hDev_0, BAR2, 0x02C00014-0x02800000, &RdReg);//获取PCISTATCLR
		RdReg = RdReg | 0x02000000;
		WDC_WriteAddr32(hDev_0, BAR2, 0x02C00014-0x02800000, RdReg);  //清中断
		
		WDC_ReadAddr32(hDev_0, BAR2, 0x02C00024-0x02800000, &RdReg);//获取PCIHINTCLR
		RdReg = RdReg | 0x02000000;
		WDC_WriteAddr32(hDev_0, BAR2, 0x02C00024-0x02800000, RdReg);  //关中断	
		Int_Flag = 1;
		//----------------------------------------------
		//-----------添加中断处理程序------------------
		TraceLog("hu: Succeed to receive the interrupt%d of the PCI driver0.\n",Int_Flag);
		PostMessage(ghWnd[0],WM_CALLBACKMESSAGE_0,Int_Flag,0);
		
		
		//----------------------------------------------
		WDC_ReadAddr32(hDev_0, BAR2, 0x02C00020-0x02800000, &RdReg);//获取PCIHINTSET
		RdReg = RdReg | 0x02000000;
		WDC_WriteAddr32(hDev_0, BAR2, 0x02C00020-0x02800000, RdReg);  //开中断
	}
	else if ((RdReg & 0x01000000) == 0x01000000)
	{
		WDC_ReadAddr32(hDev_0, BAR2, 0x02C00014-0x02800000, &RdReg);//获取PCISTATCLR
		RdReg = RdReg | 0x01000000;
		WDC_WriteAddr32(hDev_0, BAR2, 0x02C00014-0x02800000, RdReg);  //清中断
		
		WDC_ReadAddr32(hDev_0, BAR2, 0x02C00024-0x02800000, &RdReg);//获取PCIHINTCLR
		RdReg = RdReg | 0x01000000;
		WDC_WriteAddr32(hDev_0, BAR2, 0x02C00024-0x02800000, RdReg);  //关中断
		Int_Flag=0;
		//----------------------------------------------
		//-----------添加中断处理程序------------------处理PCI_EDMA PC――>DSP 的中断
		TraceLog("hu: Succeed to receive the interrupt%d of the PCI driver0.\n",Int_Flag);
		PostMessage(ghWnd[0],WM_CALLBACKMESSAGE_0,Int_Flag,0);



		//----------------------------------------------
		WDC_ReadAddr32(hDev_0, BAR2, 0x02C00020-0x02800000, &RdReg);//获取PCIHINTSET
		RdReg = RdReg | 0x01000000;
		WDC_WriteAddr32(hDev_0, BAR2, 0x02C00020-0x02800000, RdReg);  //开中断

	}
	
	/*
    printf("Got interrupt number %ld\n", pIntResult->dwCounter);
    printf("Interrupt Type: %s\n",
	WDC_DIAG_IntTypeDescriptionGet(pIntResult->dwEnabledIntType));
    if (WDC_INT_IS_MSI(pIntResult->dwEnabledIntType))
	printf("Message Data: 0x%lx\n", pIntResult->dwLastMessage);
	*/
	

}

// hu 用户模式下的中断句柄回调函数
// 作用：该函数在收到中断后将被执行
/* Diagnostics interrupt handler routine 1 */
void DiagIntHandler_1(WDC_DEVICE_HANDLE hDev_1, PCI_DRIVER_INT_RESULT *pIntResult) //## 此中断函数会被PC机不停调用，
{																		//##必须把需要的处理程序写在“添加中断处理程序处”
/* TODO: You can modify this function in order to implement your own
	diagnostics interrupt handler routine */
	// PWDC_DEVICE pDev = (PWDC_DEVICE)hDev;
	UINT32 RdReg;
//	Int_Flag = 0;

	WDC_ReadAddr32(hDev_1, BAR2, 0x02C00010-0x02800000, &RdReg);//判断是否为DSP发起的中断
	if ((RdReg & 0x08000000) == 0x08000000)
	{
		WDC_ReadAddr32(hDev_1, BAR2, 0x02C00014-0x02800000, &RdReg);//获取PCISTATCLR
		RdReg = RdReg | 0x08000000;
		WDC_WriteAddr32(hDev_1, BAR2, 0x02C00014-0x02800000, RdReg);  //清中断

		WDC_ReadAddr32(hDev_1, BAR2, 0x02C00024-0x02800000, &RdReg);//获取PCIHINTCLR
		RdReg = RdReg | 0x08000000;
		WDC_WriteAddr32(hDev_1, BAR2, 0x02C00024-0x02800000, RdReg);  //关中断
		Int_Flag=3;
		//----------------------------------------------
		//-----------添加中断处理程序------------------
	//	WDC_DMASyncIo(pDmaReceive);
	//	memcpy(EDMA_Receive,pBufReceive,4*1024);
	//	WDC_DMABufUnlock(pDmaReceive);
		TraceLog("hu: Succeed to receive the interrupt%d of the PCI driver1.\n",Int_Flag);
		PostMessage(ghWnd[1],WM_CALLBACKMESSAGE_0,Int_Flag,1);
		
		//----------------------------------------------
		WDC_ReadAddr32(hDev_1, BAR2, 0x02C00020-0x02800000, &RdReg);//获取PCIHINTSET
		RdReg = RdReg | 0x08000000;
		WDC_WriteAddr32(hDev_1, BAR2, 0x02C00020-0x02800000, RdReg);  //开中断
	}
	else if ((RdReg & 0x04000000) == 0x04000000)
	{
		WDC_ReadAddr32(hDev_1, BAR2, 0x02C00014-0x02800000, &RdReg);//获取PCISTATCLR
		RdReg = RdReg | 0x04000000;
		WDC_WriteAddr32(hDev_1, BAR2, 0x02C00014-0x02800000, RdReg);  //清中断
		
		WDC_ReadAddr32(hDev_1, BAR2, 0x02C00024-0x02800000, &RdReg);//获取PCIHINTCLR
		RdReg = RdReg | 0x04000000;
		WDC_WriteAddr32(hDev_1, BAR2, 0x02C00024-0x02800000, RdReg);  //关中断
		Int_Flag=2;
		//----------------------------------------------
		//-----------添加中断处理程序------------------
		TraceLog("hu: Succeed to receive the interrupt%d of the PCI driver1.\n",Int_Flag);
		PostMessage(ghWnd[1],WM_CALLBACKMESSAGE_0,Int_Flag,1);
		
		
		//----------------------------------------------
		WDC_ReadAddr32(hDev_1, BAR2, 0x02C00020-0x02800000, &RdReg);//获取PCIHINTSET
		RdReg = RdReg | 0x04000000;
		WDC_WriteAddr32(hDev_1, BAR2, 0x02C00020-0x02800000, RdReg);  //开中断
	}
	else if ((RdReg & 0x02000000) == 0x02000000)
	{
		WDC_ReadAddr32(hDev_1, BAR2, 0x02C00014-0x02800000, &RdReg);//获取PCISTATCLR
		RdReg = RdReg | 0x02000000;
		WDC_WriteAddr32(hDev_1, BAR2, 0x02C00014-0x02800000, RdReg);  //清中断
		
		WDC_ReadAddr32(hDev_1, BAR2, 0x02C00024-0x02800000, &RdReg);//获取PCIHINTCLR
		RdReg = RdReg | 0x02000000;
		WDC_WriteAddr32(hDev_1, BAR2, 0x02C00024-0x02800000, RdReg);  //关中断	
		Int_Flag = 1;
		//----------------------------------------------
		//-----------添加中断处理程序------------------
		TraceLog("hu: Succeed to receive the interrupt%d of the PCI driver1.\n",Int_Flag);
		PostMessage(ghWnd[1],WM_CALLBACKMESSAGE_0,Int_Flag,1);
		
		
		//----------------------------------------------
		WDC_ReadAddr32(hDev_1, BAR2, 0x02C00020-0x02800000, &RdReg);//获取PCIHINTSET
		RdReg = RdReg | 0x02000000;
		WDC_WriteAddr32(hDev_1, BAR2, 0x02C00020-0x02800000, RdReg);  //开中断
	}
	else if ((RdReg & 0x01000000) == 0x01000000)
	{
		WDC_ReadAddr32(hDev_1, BAR2, 0x02C00014-0x02800000, &RdReg);//获取PCISTATCLR
		RdReg = RdReg | 0x01000000;
		WDC_WriteAddr32(hDev_1, BAR2, 0x02C00014-0x02800000, RdReg);  //清中断
		
		WDC_ReadAddr32(hDev_1, BAR2, 0x02C00024-0x02800000, &RdReg);//获取PCIHINTCLR
		RdReg = RdReg | 0x01000000;
		WDC_WriteAddr32(hDev_1, BAR2, 0x02C00024-0x02800000, RdReg);  //关中断
		Int_Flag=0;
		//----------------------------------------------
		//-----------添加中断处理程序------------------处理PCI_EDMA PC――>DSP 的中断
		TraceLog("hu: Succeed to receive the interrupt%d of the PCI driver1.\n",Int_Flag);
		PostMessage(ghWnd[1],WM_CALLBACKMESSAGE_0,Int_Flag,1);



		//----------------------------------------------
		WDC_ReadAddr32(hDev_1, BAR2, 0x02C00020-0x02800000, &RdReg);//获取PCIHINTSET
		RdReg = RdReg | 0x01000000;
		WDC_WriteAddr32(hDev_1, BAR2, 0x02C00020-0x02800000, RdReg);  //开中断

	}
	
	/*
    printf("Got interrupt number %ld\n", pIntResult->dwCounter);
    printf("Interrupt Type: %s\n",
	WDC_DIAG_IntTypeDescriptionGet(pIntResult->dwEnabledIntType));
    if (WDC_INT_IS_MSI(pIntResult->dwEnabledIntType))
	printf("Message Data: 0x%lx\n", pIntResult->dwLastMessage);
	*/
	

}

// hu 用户模式下的中断句柄回调函数
// 作用：该函数在收到中断后将被执行
/* Diagnostics interrupt handler routine 1 */
void DiagIntHandler_2(WDC_DEVICE_HANDLE hDev_2, PCI_DRIVER_INT_RESULT *pIntResult) //## 此中断函数会被PC机不停调用，
{																		//##必须把需要的处理程序写在“添加中断处理程序处”
/* TODO: You can modify this function in order to implement your own
	diagnostics interrupt handler routine */
	// PWDC_DEVICE pDev = (PWDC_DEVICE)hDev;
	UINT32 RdReg;
//	Int_Flag = 0;

	WDC_ReadAddr32(hDev_2, BAR2, 0x02C00010-0x02800000, &RdReg);//判断是否为DSP发起的中断
	if ((RdReg & 0x08000000) == 0x08000000)
	{
		WDC_ReadAddr32(hDev_2, BAR2, 0x02C00014-0x02800000, &RdReg);//获取PCISTATCLR
		RdReg = RdReg | 0x08000000;
		WDC_WriteAddr32(hDev_2, BAR2, 0x02C00014-0x02800000, RdReg);  //清中断

		WDC_ReadAddr32(hDev_2, BAR2, 0x02C00024-0x02800000, &RdReg);//获取PCIHINTCLR
		RdReg = RdReg | 0x08000000;
		WDC_WriteAddr32(hDev_2, BAR2, 0x02C00024-0x02800000, RdReg);  //关中断
		Int_Flag=3;
		//----------------------------------------------
		//-----------添加中断处理程序------------------
	//	WDC_DMASyncIo(pDmaReceive);
	//	memcpy(EDMA_Receive,pBufReceive,4*1024);
	//	WDC_DMABufUnlock(pDmaReceive);
		TraceLog("hu: Succeed to receive the interrupt%d of the PCI driver1.\n",Int_Flag);
		PostMessage(ghWnd[2],WM_CALLBACKMESSAGE_0,Int_Flag,2);
		
		//----------------------------------------------
		WDC_ReadAddr32(hDev_2, BAR2, 0x02C00020-0x02800000, &RdReg);//获取PCIHINTSET
		RdReg = RdReg | 0x08000000;
		WDC_WriteAddr32(hDev_2, BAR2, 0x02C00020-0x02800000, RdReg);  //开中断
	}
	else if ((RdReg & 0x04000000) == 0x04000000)
	{
		WDC_ReadAddr32(hDev_2, BAR2, 0x02C00014-0x02800000, &RdReg);//获取PCISTATCLR
		RdReg = RdReg | 0x04000000;
		WDC_WriteAddr32(hDev_2, BAR2, 0x02C00014-0x02800000, RdReg);  //清中断
		
		WDC_ReadAddr32(hDev_2, BAR2, 0x02C00024-0x02800000, &RdReg);//获取PCIHINTCLR
		RdReg = RdReg | 0x04000000;
		WDC_WriteAddr32(hDev_2, BAR2, 0x02C00024-0x02800000, RdReg);  //关中断
		Int_Flag=2;
		//----------------------------------------------
		//-----------添加中断处理程序------------------
		TraceLog("hu: Succeed to receive the interrupt%d of the PCI driver1.\n",Int_Flag);
		PostMessage(ghWnd[2],WM_CALLBACKMESSAGE_0,Int_Flag,2);
		
		
		//----------------------------------------------
		WDC_ReadAddr32(hDev_2, BAR2, 0x02C00020-0x02800000, &RdReg);//获取PCIHINTSET
		RdReg = RdReg | 0x04000000;
		WDC_WriteAddr32(hDev_2, BAR2, 0x02C00020-0x02800000, RdReg);  //开中断
	}
	else if ((RdReg & 0x02000000) == 0x02000000)
	{
		WDC_ReadAddr32(hDev_2, BAR2, 0x02C00014-0x02800000, &RdReg);//获取PCISTATCLR
		RdReg = RdReg | 0x02000000;
		WDC_WriteAddr32(hDev_2, BAR2, 0x02C00014-0x02800000, RdReg);  //清中断
		
		WDC_ReadAddr32(hDev_2, BAR2, 0x02C00024-0x02800000, &RdReg);//获取PCIHINTCLR
		RdReg = RdReg | 0x02000000;
		WDC_WriteAddr32(hDev_2, BAR2, 0x02C00024-0x02800000, RdReg);  //关中断	
		Int_Flag = 1;
		//----------------------------------------------
		//-----------添加中断处理程序------------------
		TraceLog("hu: Succeed to receive the interrupt%d of the PCI driver1.\n",Int_Flag);
		PostMessage(ghWnd[2],WM_CALLBACKMESSAGE_0,Int_Flag,2);
		
		
		//----------------------------------------------
		WDC_ReadAddr32(hDev_2, BAR2, 0x02C00020-0x02800000, &RdReg);//获取PCIHINTSET
		RdReg = RdReg | 0x02000000;
		WDC_WriteAddr32(hDev_2, BAR2, 0x02C00020-0x02800000, RdReg);  //开中断
	}
	else if ((RdReg & 0x01000000) == 0x01000000)
	{
		WDC_ReadAddr32(hDev_2, BAR2, 0x02C00014-0x02800000, &RdReg);//获取PCISTATCLR
		RdReg = RdReg | 0x01000000;
		WDC_WriteAddr32(hDev_2, BAR2, 0x02C00014-0x02800000, RdReg);  //清中断
		
		WDC_ReadAddr32(hDev_2, BAR2, 0x02C00024-0x02800000, &RdReg);//获取PCIHINTCLR
		RdReg = RdReg | 0x01000000;
		WDC_WriteAddr32(hDev_2, BAR2, 0x02C00024-0x02800000, RdReg);  //关中断
		Int_Flag=0;
		//----------------------------------------------
		//-----------添加中断处理程序------------------处理PCI_EDMA PC――>DSP 的中断
		TraceLog("hu: Succeed to receive the interrupt%d of the PCI driver1.\n",Int_Flag);
		PostMessage(ghWnd[2],WM_CALLBACKMESSAGE_0,Int_Flag,2);



		//----------------------------------------------
		WDC_ReadAddr32(hDev_2, BAR2, 0x02C00020-0x02800000, &RdReg);//获取PCIHINTSET
		RdReg = RdReg | 0x01000000;
		WDC_WriteAddr32(hDev_2, BAR2, 0x02C00020-0x02800000, RdReg);  //开中断

	}
	
	/*
    printf("Got interrupt number %ld\n", pIntResult->dwCounter);
    printf("Interrupt Type: %s\n",
	WDC_DIAG_IntTypeDescriptionGet(pIntResult->dwEnabledIntType));
    if (WDC_INT_IS_MSI(pIntResult->dwEnabledIntType))
	printf("Message Data: 0x%lx\n", pIntResult->dwLastMessage);
	*/
	

}

// hu 用户模式下的中断句柄回调函数
// 作用：该函数在收到中断后将被执行
/* Diagnostics interrupt handler routine 1 */
void DiagIntHandler_3(WDC_DEVICE_HANDLE hDev_3, PCI_DRIVER_INT_RESULT *pIntResult) //## 此中断函数会被PC机不停调用，
{																		//##必须把需要的处理程序写在“添加中断处理程序处”
/* TODO: You can modify this function in order to implement your own
	diagnostics interrupt handler routine */
	// PWDC_DEVICE pDev = (PWDC_DEVICE)hDev;
	UINT32 RdReg;
//	Int_Flag = 0;

	WDC_ReadAddr32(hDev_3, BAR2, 0x02C00010-0x02800000, &RdReg);//判断是否为DSP发起的中断
	if ((RdReg & 0x08000000) == 0x08000000)
	{
		WDC_ReadAddr32(hDev_3, BAR2, 0x02C00014-0x02800000, &RdReg);//获取PCISTATCLR
		RdReg = RdReg | 0x08000000;
		WDC_WriteAddr32(hDev_3, BAR2, 0x02C00014-0x02800000, RdReg);  //清中断

		WDC_ReadAddr32(hDev_3, BAR2, 0x02C00024-0x02800000, &RdReg);//获取PCIHINTCLR
		RdReg = RdReg | 0x08000000;
		WDC_WriteAddr32(hDev_3, BAR2, 0x02C00024-0x02800000, RdReg);  //关中断
		Int_Flag=3;
		//----------------------------------------------
		//-----------添加中断处理程序------------------
	//	WDC_DMASyncIo(pDmaReceive);
	//	memcpy(EDMA_Receive,pBufReceive,4*1024);
	//	WDC_DMABufUnlock(pDmaReceive);
		TraceLog("hu: Succeed to receive the interrupt%d of the PCI driver1.\n",Int_Flag);
		PostMessage(ghWnd[3],WM_CALLBACKMESSAGE_0,Int_Flag,3);
		
		//----------------------------------------------
		WDC_ReadAddr32(hDev_3, BAR2, 0x02C00020-0x02800000, &RdReg);//获取PCIHINTSET
		RdReg = RdReg | 0x08000000;
		WDC_WriteAddr32(hDev_3, BAR2, 0x02C00020-0x02800000, RdReg);  //开中断
	}
	else if ((RdReg & 0x04000000) == 0x04000000)
	{
		WDC_ReadAddr32(hDev_3, BAR2, 0x02C00014-0x02800000, &RdReg);//获取PCISTATCLR
		RdReg = RdReg | 0x04000000;
		WDC_WriteAddr32(hDev_3, BAR2, 0x02C00014-0x02800000, RdReg);  //清中断
		
		WDC_ReadAddr32(hDev_3, BAR2, 0x02C00024-0x02800000, &RdReg);//获取PCIHINTCLR
		RdReg = RdReg | 0x04000000;
		WDC_WriteAddr32(hDev_3, BAR2, 0x02C00024-0x02800000, RdReg);  //关中断
		Int_Flag=2;
		//----------------------------------------------
		//-----------添加中断处理程序------------------
		TraceLog("hu: Succeed to receive the interrupt%d of the PCI driver1.\n",Int_Flag);
		PostMessage(ghWnd[3],WM_CALLBACKMESSAGE_0,Int_Flag,3);
		
		
		//----------------------------------------------
		WDC_ReadAddr32(hDev_3, BAR2, 0x02C00020-0x02800000, &RdReg);//获取PCIHINTSET
		RdReg = RdReg | 0x04000000;
		WDC_WriteAddr32(hDev_3, BAR2, 0x02C00020-0x02800000, RdReg);  //开中断
	}
	else if ((RdReg & 0x02000000) == 0x02000000)
	{
		WDC_ReadAddr32(hDev_3, BAR2, 0x02C00014-0x02800000, &RdReg);//获取PCISTATCLR
		RdReg = RdReg | 0x02000000;
		WDC_WriteAddr32(hDev_3, BAR2, 0x02C00014-0x02800000, RdReg);  //清中断
		
		WDC_ReadAddr32(hDev_3, BAR2, 0x02C00024-0x02800000, &RdReg);//获取PCIHINTCLR
		RdReg = RdReg | 0x02000000;
		WDC_WriteAddr32(hDev_3, BAR2, 0x02C00024-0x02800000, RdReg);  //关中断	
		Int_Flag = 1;
		//----------------------------------------------
		//-----------添加中断处理程序------------------
		TraceLog("hu: Succeed to receive the interrupt%d of the PCI driver1.\n",Int_Flag);
		PostMessage(ghWnd[3],WM_CALLBACKMESSAGE_0,Int_Flag,3);
		
		
		//----------------------------------------------
		WDC_ReadAddr32(hDev_3, BAR2, 0x02C00020-0x02800000, &RdReg);//获取PCIHINTSET
		RdReg = RdReg | 0x02000000;
		WDC_WriteAddr32(hDev_3, BAR2, 0x02C00020-0x02800000, RdReg);  //开中断
	}
	else if ((RdReg & 0x01000000) == 0x01000000)
	{
		WDC_ReadAddr32(hDev_3, BAR2, 0x02C00014-0x02800000, &RdReg);//获取PCISTATCLR
		RdReg = RdReg | 0x01000000;
		WDC_WriteAddr32(hDev_3, BAR2, 0x02C00014-0x02800000, RdReg);  //清中断
		
		WDC_ReadAddr32(hDev_3, BAR2, 0x02C00024-0x02800000, &RdReg);//获取PCIHINTCLR
		RdReg = RdReg | 0x01000000;
		WDC_WriteAddr32(hDev_3, BAR2, 0x02C00024-0x02800000, RdReg);  //关中断
		Int_Flag=0;
		//----------------------------------------------
		//-----------添加中断处理程序------------------处理PCI_EDMA PC――>DSP 的中断
		TraceLog("hu: Succeed to receive the interrupt%d of the PCI driver1.\n",Int_Flag);
		PostMessage(ghWnd[3],WM_CALLBACKMESSAGE_0,Int_Flag,3);



		//----------------------------------------------
		WDC_ReadAddr32(hDev_3, BAR2, 0x02C00020-0x02800000, &RdReg);//获取PCIHINTSET
		RdReg = RdReg | 0x01000000;
		WDC_WriteAddr32(hDev_3, BAR2, 0x02C00020-0x02800000, RdReg);  //开中断

	}
	
	/*
    printf("Got interrupt number %ld\n", pIntResult->dwCounter);
    printf("Interrupt Type: %s\n",
	WDC_DIAG_IntTypeDescriptionGet(pIntResult->dwEnabledIntType));
    if (WDC_INT_IS_MSI(pIntResult->dwEnabledIntType))
	printf("Message Data: 0x%lx\n", pIntResult->dwLastMessage);
	*/
	

}

// hu 用户模式下的中断句柄回调函数
// 作用：该函数在收到中断后将被执行
/* Diagnostics interrupt handler routine 1 */
void DiagIntHandler_4(WDC_DEVICE_HANDLE hDev_4, PCI_DRIVER_INT_RESULT *pIntResult) //## 此中断函数会被PC机不停调用，
{																		//##必须把需要的处理程序写在“添加中断处理程序处”
/* TODO: You can modify this function in order to implement your own
	diagnostics interrupt handler routine */
	// PWDC_DEVICE pDev = (PWDC_DEVICE)hDev;
	UINT32 RdReg;
//	Int_Flag = 0;

	WDC_ReadAddr32(hDev_4, BAR2, 0x02C00010-0x02800000, &RdReg);//判断是否为DSP发起的中断
	if ((RdReg & 0x08000000) == 0x08000000)
	{
		WDC_ReadAddr32(hDev_4, BAR2, 0x02C00014-0x02800000, &RdReg);//获取PCISTATCLR
		RdReg = RdReg | 0x08000000;
		WDC_WriteAddr32(hDev_4, BAR2, 0x02C00014-0x02800000, RdReg);  //清中断

		WDC_ReadAddr32(hDev_4, BAR2, 0x02C00024-0x02800000, &RdReg);//获取PCIHINTCLR
		RdReg = RdReg | 0x08000000;
		WDC_WriteAddr32(hDev_4, BAR2, 0x02C00024-0x02800000, RdReg);  //关中断
		Int_Flag=3;
		//----------------------------------------------
		//-----------添加中断处理程序------------------
	//	WDC_DMASyncIo(pDmaReceive);
	//	memcpy(EDMA_Receive,pBufReceive,4*1024);
	//	WDC_DMABufUnlock(pDmaReceive);
		TraceLog("hu: Succeed to receive the interrupt%d of the PCI driver1.\n",Int_Flag);
		PostMessage(ghWnd[4],WM_CALLBACKMESSAGE_0,Int_Flag,4);
		
		//----------------------------------------------
		WDC_ReadAddr32(hDev_4, BAR2, 0x02C00020-0x02800000, &RdReg);//获取PCIHINTSET
		RdReg = RdReg | 0x08000000;
		WDC_WriteAddr32(hDev_4, BAR2, 0x02C00020-0x02800000, RdReg);  //开中断
	}
	else if ((RdReg & 0x04000000) == 0x04000000)
	{
		WDC_ReadAddr32(hDev_4, BAR2, 0x02C00014-0x02800000, &RdReg);//获取PCISTATCLR
		RdReg = RdReg | 0x04000000;
		WDC_WriteAddr32(hDev_4, BAR2, 0x02C00014-0x02800000, RdReg);  //清中断
		
		WDC_ReadAddr32(hDev_4, BAR2, 0x02C00024-0x02800000, &RdReg);//获取PCIHINTCLR
		RdReg = RdReg | 0x04000000;
		WDC_WriteAddr32(hDev_4, BAR2, 0x02C00024-0x02800000, RdReg);  //关中断
		Int_Flag=2;
		//----------------------------------------------
		//-----------添加中断处理程序------------------
		TraceLog("hu: Succeed to receive the interrupt%d of the PCI driver1.\n",Int_Flag);
		PostMessage(ghWnd[4],WM_CALLBACKMESSAGE_0,Int_Flag,4);
		
		
		//----------------------------------------------
		WDC_ReadAddr32(hDev_4, BAR2, 0x02C00020-0x02800000, &RdReg);//获取PCIHINTSET
		RdReg = RdReg | 0x04000000;
		WDC_WriteAddr32(hDev_4, BAR2, 0x02C00020-0x02800000, RdReg);  //开中断
	}
	else if ((RdReg & 0x02000000) == 0x02000000)
	{
		WDC_ReadAddr32(hDev_4, BAR2, 0x02C00014-0x02800000, &RdReg);//获取PCISTATCLR
		RdReg = RdReg | 0x02000000;
		WDC_WriteAddr32(hDev_4, BAR2, 0x02C00014-0x02800000, RdReg);  //清中断
		
		WDC_ReadAddr32(hDev_4, BAR2, 0x02C00024-0x02800000, &RdReg);//获取PCIHINTCLR
		RdReg = RdReg | 0x02000000;
		WDC_WriteAddr32(hDev_4, BAR2, 0x02C00024-0x02800000, RdReg);  //关中断	
		Int_Flag = 1;
		//----------------------------------------------
		//-----------添加中断处理程序------------------
		TraceLog("hu: Succeed to receive the interrupt%d of the PCI driver1.\n",Int_Flag);
		PostMessage(ghWnd[4],WM_CALLBACKMESSAGE_0,Int_Flag,4);
		
		
		//----------------------------------------------
		WDC_ReadAddr32(hDev_4, BAR2, 0x02C00020-0x02800000, &RdReg);//获取PCIHINTSET
		RdReg = RdReg | 0x02000000;
		WDC_WriteAddr32(hDev_4, BAR2, 0x02C00020-0x02800000, RdReg);  //开中断
	}
	else if ((RdReg & 0x01000000) == 0x01000000)
	{
		WDC_ReadAddr32(hDev_4, BAR2, 0x02C00014-0x02800000, &RdReg);//获取PCISTATCLR
		RdReg = RdReg | 0x01000000;
		WDC_WriteAddr32(hDev_4, BAR2, 0x02C00014-0x02800000, RdReg);  //清中断
		
		WDC_ReadAddr32(hDev_4, BAR2, 0x02C00024-0x02800000, &RdReg);//获取PCIHINTCLR
		RdReg = RdReg | 0x01000000;
		WDC_WriteAddr32(hDev_4, BAR2, 0x02C00024-0x02800000, RdReg);  //关中断
		Int_Flag=0;
		//----------------------------------------------
		//-----------添加中断处理程序------------------处理PCI_EDMA PC――>DSP 的中断
		TraceLog("hu: Succeed to receive the interrupt%d of the PCI driver1.\n",Int_Flag);
		PostMessage(ghWnd[4],WM_CALLBACKMESSAGE_0,Int_Flag,4);



		//----------------------------------------------
		WDC_ReadAddr32(hDev_4, BAR2, 0x02C00020-0x02800000, &RdReg);//获取PCIHINTSET
		RdReg = RdReg | 0x01000000;
		WDC_WriteAddr32(hDev_4, BAR2, 0x02C00020-0x02800000, RdReg);  //开中断

	}
	
	/*
    printf("Got interrupt number %ld\n", pIntResult->dwCounter);
    printf("Interrupt Type: %s\n",
	WDC_DIAG_IntTypeDescriptionGet(pIntResult->dwEnabledIntType));
    if (WDC_INT_IS_MSI(pIntResult->dwEnabledIntType))
	printf("Message Data: 0x%lx\n", pIntResult->dwLastMessage);
	*/
	

}

// hu 屏蔽PCI中断
// 返回值：0 -- 成功 
//         1 -- 屏蔽PCI中断失败
DWORD DisInterrupt_1(int deviceX)
{
    DWORD dwStatus;
	int IntStatus;

	TraceLog("hu: Start to run the function: DisInterrupt_1...\n");

	hDevNow = hDev[deviceX];

	IntStatus=WDC_IntIsEnabled(hDevNow);// hu 检查中断是否使能	
	if (IntStatus)
	{
		dwStatus = WDC_IntDisable(hDevNow);
	}
	else
	{
		TraceLog("hu: The interrupts of the PCI driver%d have been disabled.\n",deviceX);
		return 0;
	}

	if (WD_STATUS_SUCCESS != dwStatus)
	{
		WDC_Err("hu: Failed to disable the interrupts of the PCI driver%d. Error 0x%lx - %s\n",deviceX,dwStatus, Stat2Str(dwStatus));
		return 1;
	}

	TraceLog("hu: Succeed to disable the interrupts of the PCI driver%d.\n",deviceX);
    return 0;
}

// hu 发送中断
// 返回值：0 -- 成功
DWORD SendInterrupt(int deviceX)
{
	UINT32 RdReg;

	TraceLog("hu: Start to run the function: SendInterrupt...\n");

	hDevNow = hDev[deviceX];

	WDC_ReadAddr32(hDevNow, BAR2, 0x02C00010-0x02800000, &RdReg);
	RdReg = RdReg | 0x80000000;
	WDC_WriteAddr32(hDevNow, BAR2, 0x02C00010-0x02800000, RdReg);
	
	TraceLog("hu: Succeed to send the interrupts of the PCI driver%d.\n",deviceX);
	return 0;
}

// hu 申请物理空间
// 返回值：0 -- 成功 
//         1 -- 所申请的物理空间数量超过上限10
//         2 -- 申请物理空间失败
//         3 -- CPU缓存与物理空间同步失败
DWORD  ApplyForPhysicalAddress(int deviceX, DWORD dwDMABufSize, PVOID * pBufAddress, DWORD * pBufPhysicalAddress, DWORD * DMAHandle)
{
	PPCI_DRIVER_DEV_CTX           pDevCtx = NULL;
    DWORD dwStatus;
	int i;
	UINT32 u32LocalAddr=0x0;

	TraceLog("hu: Start to run the function: ApplyForPhysicalAddress...\n");

	hDevNow = hDev[deviceX];
	for(i=0;i<10;i++)
	{
		if(pDmaGroup[deviceX][i] == 0)
		{
			break;
		}
	}
	if(i == 10)
	{
		WDC_Err("hu: The number of the physical address must be under 11.\n");
		return 1;
	}
	else
	{
		dwStatus = WDC_DMAContigBufLock(hDevNow, pBufAddress, DMA_TO_DEVICE, dwDMABufSize, &pDmaGroup[deviceX][i]);
		if (WD_STATUS_SUCCESS != dwStatus)
		{
			WDC_Err("hu: Failed to apply the physical address of the PCI driver%d. Error 0x%lx - %s\n",deviceX,dwStatus, Stat2Str(dwStatus));
			return 2;
		}
		* pBufPhysicalAddress = (DWORD) pDmaGroup[deviceX][i]->Page[0].pPhysicalAddr;
		* DMAHandle = i;

		dwStatus = WDC_DMASyncCpu(pDmaGroup[deviceX][i]);
		if (WD_STATUS_SUCCESS != dwStatus)
		{
			WDC_Err("hu: Failed to synchronize the cache of all CPUs with the physical address of the PCI driver%d. Error 0x%lx - %s\n",deviceX,dwStatus, Stat2Str(dwStatus));
			return 3;
		}
	}

	TraceLog("hu: Succeed to apply the physical address of the PCI driver%d.\n",deviceX);
	return 0;

	//dwStatus_2 = WDC_DMAContigBufLock(hDev, pBufReceive, DMA_FROM_DEVICE, 1024*1024*1, &pDmaReceive);
	
	//##将申请到的地址写入bar0
	
	//WDC_WriteAddr32(hDev, BAR0, (UINT32) 0x410, (UINT32) pDmaSend->Page[0].pPhysicalAddr);//
	//u32LocalAddr=u32LocalAddr+4;
	//WDC_WriteAddr32(hDev, BAR0, (UINT32) 0x414, (UINT32) 10240);//## 写入空间大小  (UINT32) pDmaSend->Page[0].dwBytes
	//##将申请到的地址写入bar0
	//u32LocalAddr=u32LocalAddr+4;
	//WDC_WriteAddr32(hDev, BAR0, u32LocalAddr, (UINT32) pDmaReceive->Page[0].pPhysicalAddr);//
	//u32LocalAddr=u32LocalAddr+4;
	//WDC_WriteAddr32(hDev, BAR0, u32LocalAddr, (UINT32) pDmaReceive->Page[0].dwBytes);//## 写入空间大小
}

// hu 释放物理空间
// 返回值：0 -- 成功 
//         1 -- I/O缓存与物理空间同步失败
//         2 -- 释放物理空间失败
DWORD  FreePhysicalAddress(int deviceX, DWORD DMAHandle)
{
	DWORD dwStatus;
	int i;
	
	TraceLog("hu: Start to run the function: FreePhysicalAddress...\n");

	i = DMAHandle;
	hDevNow = hDev[deviceX];
	if(pDmaGroup[deviceX][i] != 0)
	{
		dwStatus = WDC_DMASyncIo(pDmaGroup[deviceX][i]);
		if (WD_STATUS_SUCCESS != dwStatus)
		{
			WDC_Err("hu: Failed to synchronize the I/O caches with the physical address of the PCI driver%d. Error 0x%lx - %s\n",deviceX,dwStatus, Stat2Str(dwStatus));
			return 1;
		}

		dwStatus = WDC_DMABufUnlock(pDmaGroup[deviceX][i]);
		if (WD_STATUS_SUCCESS != dwStatus)
		{
			WDC_Err("hu: Failed to free the physical address of the PCI driver%d. Error 0x%lx - %s\n",deviceX,dwStatus, Stat2Str(dwStatus));
			return 2;
		}

		pDmaGroup[deviceX][i] = 0;
	}

	TraceLog("hu: Succeed to free the physical address of the PCI driver%d.\n",deviceX);
	return 0;
}

// hu 关闭PCI设备
// 返回值：0 -- 成功 
//         1 -- 关闭PCI驱动失败
//         2 -- 卸载设备驱动库失败
//         3 -- 关闭PCI驱动与卸载设备驱动库失败
DWORD Close_PCI(int deviceX)
{
	DWORD dwStatus,ii=0,jj=0;

	TraceLog("hu: Start to run the function: Close_PCI...\n");

	hDevNow = hDev[deviceX];
	dwStatus = PCI_DRIVER_DeviceClose(hDevNow);
	if (!dwStatus)
	{
		ii = 1;
		WDC_Err("hu: Failed to close the PCI driver%d.\n",deviceX);
	}

	dwStatus = PCI_DRIVER_LibUninit();
	if (WD_STATUS_SUCCESS != dwStatus)
	{
		jj = 2;
		WDC_Err("hu: Failed to uninitialize the PCI driver library. Error 0x%lx - %s\n",dwStatus, Stat2Str(dwStatus));
	}

	TraceLog("hu: Succeed to close the PCI driver.\n");
    return (ii+jj);
}

/* -----------------------------------------------
    PCI_DRIVER and WDC library initialize/uninit
   ----------------------------------------------- */
DWORD PCI_DRIVER_LibInit(void)
{
    DWORD dwStatus;
 
    /* init only once */
    if (++LibInit_count > 1)
        return WD_STATUS_SUCCESS;
 
#if defined(WD_DRIVER_NAME_CHANGE)
    /* Set the driver name */
    if (!WD_DriverName(PCI_DRIVER_DEFAULT_DRIVER_NAME))
    {
        ErrLog("Failed to set the driver name for WDC library.\n");
        return WD_SYSTEM_INTERNAL_ERROR;
    }
#endif

    /* Set WDC library's debug options (default: level TRACE, output to Debug Monitor) */
    dwStatus = WDC_SetDebugOptions(WDC_DBG_DEFAULT, NULL);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        ErrLog("Failed to initialize debug options for WDC library.\n"
            "Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
        
        return dwStatus;
    }

    /* Open a handle to the driver and initialize the WDC library */
    dwStatus = WDC_DriverOpen(WDC_DRV_OPEN_DEFAULT, PCI_DRIVER_DEFAULT_LICENSE_STRING);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        ErrLog("Failed to initialize the WDC library. Error 0x%lx - %s\n",
            dwStatus, Stat2Str(dwStatus));
        
        return dwStatus;
    }

    return WD_STATUS_SUCCESS;
}

DWORD PCI_DRIVER_LibUninit(void)
{
    DWORD dwStatus;

    if (--LibInit_count > 0)
        return WD_STATUS_SUCCESS;
 
    /* Uninit the WDC library and close the handle to WinDriver */
    dwStatus = WDC_DriverClose();
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        ErrLog("Failed to uninit the WDC library. Error 0x%lx - %s\n",
            dwStatus, Stat2Str(dwStatus));
    }

    return dwStatus;
}

/* -----------------------------------------------
    Device open/close
   ----------------------------------------------- */
WDC_DEVICE_HANDLE PCI_DRIVER_DeviceOpen(const WD_PCI_CARD_INFO *pDeviceInfo)
{
    DWORD dwStatus;
    PPCI_DRIVER_DEV_CTX pDevCtx = NULL;
    WDC_DEVICE_HANDLE hDev = NULL;

    /* Validate arguments */
    if (!pDeviceInfo)
    {
        ErrLog("PCI_DRIVER_DeviceOpen: Error - NULL device information struct pointer\n");
        return NULL;
    }

    /* Allocate memory for the PCI_DRIVER device context */
    pDevCtx = (PPCI_DRIVER_DEV_CTX)malloc(sizeof (PCI_DRIVER_DEV_CTX));
    if (!pDevCtx)
    {
        ErrLog("Failed allocating memory for PCI_DRIVER device context\n");
        return NULL;
    }

    BZERO(*pDevCtx);

    /* Open a WDC device handle */
    dwStatus = WDC_PciDeviceOpen(&hDev, pDeviceInfo, pDevCtx, NULL, NULL, NULL);

    if (WD_STATUS_SUCCESS != dwStatus)
    {
        ErrLog("Failed opening a WDC device handle. Error 0x%lx - %s\n",
            dwStatus, Stat2Str(dwStatus));
        goto Error;
    }

    /* Validate device information */
    if (!DeviceValidate((PWDC_DEVICE)hDev))
        goto Error;

    /* Return handle to the new device */
    TraceLog("PCI_DRIVER_DeviceOpen: Opened a PCI_DRIVER device (handle 0x%p)\n", hDev);
    return hDev;

Error:    
    if (hDev)
        PCI_DRIVER_DeviceClose(hDev);
    else
        free(pDevCtx);
    
    return NULL;
}

BOOL PCI_DRIVER_DeviceClose(WDC_DEVICE_HANDLE hDev)
{
    DWORD dwStatus;
    PWDC_DEVICE pDev = (PWDC_DEVICE)hDev;
    PPCI_DRIVER_DEV_CTX pDevCtx;
    
    TraceLog("PCI_DRIVER_DeviceClose entered. Device handle: 0x%p\n", hDev);

    if (!hDev)
    {
        ErrLog("PCI_DRIVER_DeviceClose: Error - NULL device handle\n");
        return FALSE;
    }

    pDevCtx = (PPCI_DRIVER_DEV_CTX)WDC_GetDevContext(pDev);
    
    /* Disable interrupts */
    if (WDC_IntIsEnabled(hDev))
    {
        dwStatus = PCI_DRIVER_IntDisable(hDev);
        if (WD_STATUS_SUCCESS != dwStatus)
        {
            ErrLog("Failed disabling interrupts. Error 0x%lx - %s\n",
                dwStatus, Stat2Str(dwStatus));
        }
    }

    /* Close the device */
    dwStatus = WDC_PciDeviceClose(hDev);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        ErrLog("Failed closing a WDC device handle (0x%p). Error 0x%lx - %s\n",
            hDev, dwStatus, Stat2Str(dwStatus));
    }

    /* Free PCI_DRIVER device context memory */
    if (pDevCtx)
        free (pDevCtx);
    
    return (WD_STATUS_SUCCESS == dwStatus);
}

static BOOL DeviceValidate(const PWDC_DEVICE pDev)
{
    DWORD i, dwNumAddrSpaces = pDev->dwNumAddrSpaces;

    /* TODO: You can modify the implementation of this function in order to
             verify that the device has all expected resources. */
    
    /* Verify that the device has at least one active address space */
    for (i = 0; i < dwNumAddrSpaces; i++)
    {
        if (WDC_AddrSpaceIsActive(pDev, i))
            return TRUE;
    }
    
    TraceLog("Device does not have any active memory or I/O address spaces\n");
    return TRUE;
}

/* -----------------------------------------------
    Interrupts
   ----------------------------------------------- */
static void DLLCALLCONV PCI_DRIVER_IntHandler(PVOID pData)
{
    PWDC_DEVICE pDev = (PWDC_DEVICE)pData;
    PPCI_DRIVER_DEV_CTX pDevCtx = (PPCI_DRIVER_DEV_CTX)WDC_GetDevContext(pDev);
    PCI_DRIVER_INT_RESULT intResult;

    BZERO(intResult);
    intResult.dwCounter = pDev->Int.dwCounter;
    intResult.dwLost = pDev->Int.dwLost;
    intResult.waitResult = (WD_INTERRUPT_WAIT_RESULT)pDev->Int.fStopped;
    intResult.dwEnabledIntType = WDC_GET_ENABLED_INT_TYPE(pDev);
    intResult.dwLastMessage = WDC_GET_ENABLED_INT_LAST_MSG(pDev);
    
    /* Execute the diagnostics application's interrupt handler routine */
    pDevCtx->funcDiagIntHandler((WDC_DEVICE_HANDLE)pDev, &intResult);
}

static BOOL IsItemExists(PWDC_DEVICE pDev, ITEM_TYPE item)
{
    int i;
    DWORD dwNumItems = pDev->cardReg.Card.dwItems;

    for (i=0; i<dwNumItems; i++)
    {
        if (pDev->cardReg.Card.Item[i].item == item)
            return TRUE;
    }

    return FALSE;
}

DWORD PCI_DRIVER_IntEnable(WDC_DEVICE_HANDLE hDev, PCI_DRIVER_INT_HANDLER funcIntHandler)
{
    DWORD dwStatus;
    PWDC_DEVICE pDev = (PWDC_DEVICE)hDev;
    PPCI_DRIVER_DEV_CTX pDevCtx;

    TraceLog("PCI_DRIVER_IntEnable entered. Device handle: 0x%p\n", hDev);

    if (!IsValidDevice(pDev, "PCI_DRIVER_IntEnable"))
        return WD_INVALID_PARAMETER;

    if (!IsItemExists(pDev, ITEM_INTERRUPT))
        return WD_OPERATION_FAILED;

    pDevCtx = (PPCI_DRIVER_DEV_CTX)WDC_GetDevContext(pDev);

    /* Check if interrupts are already enabled */
    if (WDC_IntIsEnabled(hDev))
    {
        ErrLog("Interrupts are already enabled ...\n");
        return WD_OPERATION_ALREADY_DONE;
    }

    /* Define the number of interrupt transfer commands to use */
    #define NUM_TRANS_CMDS 0

    /* NOTE: In order to correctly handle PCI interrupts, you need to
             ADD CODE HERE to set up transfer commands to read/write the
             relevant register(s) in order to correctly acknowledge the
             interrupts, as dictated by your hardware's specifications.
             When adding transfer commands, be sure to also modify the
             definition of NUM_TRANS_CMDS (above) accordingly. */

    /* Store the diag interrupt handler routine, which will be executed by
       PCI_DRIVER_IntHandler() when an interrupt is received */
    pDevCtx->funcDiagIntHandler = funcIntHandler;
    
    /* Enable the interrupts */
    /* NOTE: When adding read transfer commands, set the INTERRUPT_CMD_COPY flag
             in the 4th argument (dwOptions) passed to WDC_IntEnable() */
    dwStatus = WDC_IntEnable(hDev, NULL, 0, 0,
        PCI_DRIVER_IntHandler, (PVOID)pDev, WDC_IS_KP(hDev));
        
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        ErrLog("Failed enabling interrupts. Error 0x%lx - %s\n",
            dwStatus, Stat2Str(dwStatus));
        
        return dwStatus;
    }

    /* TODO: You can add code here to write to the device in order
             to physically enable the hardware interrupts */

    TraceLog("PCI_DRIVER_IntEnable: Interrupts enabled\n");

    return WD_STATUS_SUCCESS;
}

DWORD PCI_DRIVER_IntDisable(WDC_DEVICE_HANDLE hDev)
{
    DWORD dwStatus;
    PWDC_DEVICE pDev = (PWDC_DEVICE)hDev;
    PPCI_DRIVER_DEV_CTX pDevCtx;

    TraceLog("PCI_DRIVER_IntDisable entered. Device handle: 0x%p\n", hDev);

    if (!IsValidDevice(pDev, "PCI_DRIVER_IntDisable"))
        return WD_INVALID_PARAMETER;

    pDevCtx = (PPCI_DRIVER_DEV_CTX)WDC_GetDevContext(pDev);
 
    if (!WDC_IntIsEnabled(hDev))
    {
        ErrLog("Interrupts are already disabled ...\n");
        return WD_OPERATION_ALREADY_DONE;
    }

    /* TODO: You can add code here to write to the device in order
             to physically disable the hardware interrupts */

    /* Disable the interrupts */
    dwStatus = WDC_IntDisable(hDev);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        ErrLog("Failed disabling interrupts. Error 0x%lx - %s\n",
            dwStatus, Stat2Str(dwStatus));
    }

    return dwStatus;
}

BOOL PCI_DRIVER_IntIsEnabled(WDC_DEVICE_HANDLE hDev)
{
    if (!IsValidDevice((PWDC_DEVICE)hDev, "PCI_DRIVER_IntIsEnabled"))
        return FALSE;

    return WDC_IntIsEnabled(hDev);
}

/* -----------------------------------------------
    Plug-and-play and power management events
   ----------------------------------------------- */
static void PCI_DRIVER_EventHandler(WD_EVENT *pEvent, PVOID pData)
{
    PWDC_DEVICE pDev = (PWDC_DEVICE)pData;
    PPCI_DRIVER_DEV_CTX pDevCtx = (PPCI_DRIVER_DEV_CTX)WDC_GetDevContext(pDev);

    TraceLog("PCI_DRIVER_EventHandler entered, pData: 0x%p, dwAction 0x%lx\n",
        pData, pEvent->dwAction);
    
    /* Execute the diagnostics application's event handler function */
    pDevCtx->funcDiagEventHandler((WDC_DEVICE_HANDLE)pDev, pEvent->dwAction);
}

DWORD PCI_DRIVER_EventRegister(WDC_DEVICE_HANDLE hDev, PCI_DRIVER_EVENT_HANDLER funcEventHandler)
{
    DWORD dwStatus;
    PWDC_DEVICE pDev = (PWDC_DEVICE)hDev;
    PPCI_DRIVER_DEV_CTX pDevCtx;
    DWORD dwActions = WD_ACTIONS_ALL;
    /* TODO: Modify the above to set up the plug-and-play/power management
             events for which you wish to receive notifications.
             dwActions can be set to any combination of the WD_EVENT_ACTION
             flags defined in windrvr.h */

    TraceLog("PCI_DRIVER_EventRegister entered. Device handle: 0x%p\n", hDev);
    
    if (!IsValidDevice(pDev, "PCI_DRIVER_EventRegister"))
        return WD_INVALID_PARAMETER;

    pDevCtx = (PPCI_DRIVER_DEV_CTX)WDC_GetDevContext(pDev);

    /* Check if event is already registered */
    if (WDC_EventIsRegistered(hDev))
    {
        ErrLog("Events are already registered ...\n");
        return WD_OPERATION_ALREADY_DONE;
    }

    /* Store the diag event handler routine to be executed from PCI_DRIVER_EventHandler() upon an event */
    pDevCtx->funcDiagEventHandler = funcEventHandler;

    /* Register event */
    dwStatus = WDC_EventRegister(hDev, dwActions, PCI_DRIVER_EventHandler, hDev, FALSE);
    
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        ErrLog("Failed to register events. Error 0x%lx - %s\n",
            dwStatus, Stat2Str(dwStatus));
        return dwStatus;
    }

    TraceLog("Events registered\n");

    return WD_STATUS_SUCCESS;
}

DWORD PCI_DRIVER_EventUnregister(WDC_DEVICE_HANDLE hDev)
{
    DWORD dwStatus;
    
    TraceLog("PCI_DRIVER_EventUnregister entered. Device handle: 0x%p\n", hDev);
    
    if (!IsValidDevice((PWDC_DEVICE)hDev, "PCI_DRIVER_EventUnregister"))
        return WD_INVALID_PARAMETER;

    if (!WDC_EventIsRegistered(hDev))
    {
        ErrLog("Cannot unregister events - no events currently registered ...\n");
        return WD_OPERATION_ALREADY_DONE;
    }

    dwStatus = WDC_EventUnregister(hDev);
    
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        ErrLog("Failed to unregister events. Error 0x%lx - %s\n",
            dwStatus, Stat2Str(dwStatus));
    }

    return dwStatus;
}

BOOL PCI_DRIVER_EventIsRegistered(WDC_DEVICE_HANDLE hDev)
{
    if (!IsValidDevice((PWDC_DEVICE)hDev, "PCI_DRIVER_EventIsRegistered"))
        return FALSE;

    return WDC_EventIsRegistered(hDev);
}

/* -----------------------------------------------
    Address spaces information
   ----------------------------------------------- */
DWORD PCI_DRIVER_GetNumAddrSpaces(WDC_DEVICE_HANDLE hDev)
{
    PWDC_DEVICE pDev = (PWDC_DEVICE)hDev;
    
    if (!IsValidDevice(pDev, "PCI_DRIVER_GetNumAddrSpaces"))
        return 0;

    return pDev->dwNumAddrSpaces;
}

BOOL PCI_DRIVER_GetAddrSpaceInfo(WDC_DEVICE_HANDLE hDev, PCI_DRIVER_ADDR_SPACE_INFO *pAddrSpaceInfo)
{
    PWDC_DEVICE pDev = (PWDC_DEVICE)hDev;
    WDC_ADDR_DESC *pAddrDesc;
    DWORD dwAddrSpace, dwMaxAddrSpace;
    BOOL fIsMemory;
    
    if (!IsValidDevice(pDev, "PCI_DRIVER_GetAddrSpaceInfo"))
        return FALSE;

#if defined(DEBUG)
    if (!pAddrSpaceInfo)
    {
        ErrLog("PCI_DRIVER_GetAddrSpaceInfo: Error - NULL address space information pointer\n");
        return FALSE;
    }
#endif

    dwAddrSpace = pAddrSpaceInfo->dwAddrSpace;
    dwMaxAddrSpace = pDev->dwNumAddrSpaces - 1;

    if (dwAddrSpace > dwMaxAddrSpace)
    {
        ErrLog("PCI_DRIVER_GetAddrSpaceInfo: Error - Address space %ld is out of range (0 - %ld)\n",
            dwAddrSpace, dwMaxAddrSpace);
        return FALSE;
    }

    pAddrDesc = &pDev->pAddrDesc[dwAddrSpace];

    fIsMemory = WDC_ADDR_IS_MEM(pAddrDesc);
    
    snprintf(pAddrSpaceInfo->sName, MAX_NAME - 1, "BAR %ld", dwAddrSpace);
    snprintf(pAddrSpaceInfo->sType, MAX_TYPE - 1, fIsMemory ? "Memory" : "I/O");
        
    if (WDC_AddrSpaceIsActive(pDev, dwAddrSpace))
    {
        WD_ITEMS *pItem = &pDev->cardReg.Card.Item[pAddrDesc->dwItemIndex];
        DWORD dwAddr = fIsMemory ? pItem->I.Mem.dwPhysicalAddr : (DWORD)pItem->I.IO.dwAddr;
        
        snprintf(pAddrSpaceInfo->sDesc, MAX_DESC - 1, "0x%0*lX - 0x%0*lX (0x%lx bytes)",
            (int)WDC_SIZE_32 * 2, dwAddr,
            (int)WDC_SIZE_32 * 2, dwAddr + pAddrDesc->dwBytes - 1,
            pAddrDesc->dwBytes);
    }
    else
        snprintf(pAddrSpaceInfo->sDesc, MAX_DESC - 1, "Inactive address space");

    /* TODO: You can modify the code above to set a different address space name/description */

    return TRUE;
}

/* -----------------------------------------------
    Debugging and error handling
   ----------------------------------------------- */
static void ErrLog(const CHAR *sFormat, ...)
{
#if defined(DEBUG)
    va_list argp;
    va_start(argp, sFormat);
    vsnprintf(gsPCI_DRIVER_LastErr, sizeof(gsPCI_DRIVER_LastErr) - 1, sFormat, argp);
    WDC_Err("PCI_DRIVER lib: %s", PCI_DRIVER_GetLastErr());
    va_end(argp);
#endif
}

static void TraceLog(const CHAR *sFormat, ...)
{
#if defined(DEBUG)
    CHAR sMsg[256];
    va_list argp;
    va_start(argp, sFormat);
    vsnprintf(sMsg, sizeof(sMsg) - 1, sFormat, argp);
    WDC_Trace("PCI_DRIVER lib: %s", sMsg);
    va_end(argp);
#endif
}

const char *PCI_DRIVER_GetLastErr(void)
{
    return gsPCI_DRIVER_LastErr;
}
